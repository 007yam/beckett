{
    "docs": [
        {
            "location": "/",
            "text": "\ud83d\udcab Beckett\n\n\nHypermedia API Client Framework\n\n\n\n\nBeckett is a convention-based framework for building Python interfaces around HTTP APIs.\n\n\n\n\n\n\n\n\n\n\n\ud83d\udcd6 Features\n\n\n\n\nDefine your API client in Python instead of a data serialization language.\n\n\nEncourages good HTTP and REST practices without being too strict.\n\n\nResources are transformed into typed instances - no more raw dictionaries!\n\n\nAutomatic URL routing for RESTful interaction to your resources.\n\n\nHypermedia relationship links are automagically resolved into python methods.\n\n\nSupports hypermedia response formats such as JSONAPI and HAL. [IN DEV]\n\n\nWorks out of the box, but each resource is completely configurable.\n\n\n\n\n\ud83c\udfd7 Status\n\n\nBeckett is \nstable\n and suitable for projects, but expect occasional updates for bug fixes.\n\n\n\ud83c\udfa5 Credits\n\n\nThis package was created with \nCookiecutter\n.\n\n\nWe use \nPython Requests\n for talking HTTP.\n\n\nFree software: \nISC license",
            "title": "Home"
        },
        {
            "location": "/#beckett",
            "text": "Hypermedia API Client Framework   Beckett is a convention-based framework for building Python interfaces around HTTP APIs.",
            "title": "\ud83d\udcab Beckett"
        },
        {
            "location": "/#features",
            "text": "Define your API client in Python instead of a data serialization language.  Encourages good HTTP and REST practices without being too strict.  Resources are transformed into typed instances - no more raw dictionaries!  Automatic URL routing for RESTful interaction to your resources.  Hypermedia relationship links are automagically resolved into python methods.  Supports hypermedia response formats such as JSONAPI and HAL. [IN DEV]  Works out of the box, but each resource is completely configurable.",
            "title": "\ud83d\udcd6 Features"
        },
        {
            "location": "/#status",
            "text": "Beckett is  stable  and suitable for projects, but expect occasional updates for bug fixes.",
            "title": "\ud83c\udfd7 Status"
        },
        {
            "location": "/#credits",
            "text": "This package was created with  Cookiecutter .  We use  Python Requests  for talking HTTP.  Free software:  ISC license",
            "title": "\ud83c\udfa5 Credits"
        },
        {
            "location": "/intro/",
            "text": "Getting Started\n\n\nBeckett can be installed using \npip\n:\n\n\npip install beckett\n\n\n\n\nA Basic Client\n\n\nLet's get to grips with Beckett by writing a basic client for communicating with \nSwapi\n, the Star Wars API.\n\n\nResources\n\n\nThe first thing we'll need to do is declare a \nResource\n. Swapi has \nmany resources\n, but let's create a resource for just \nPeople\n:\n\n\n# my_resources.py\nfrom beckett import resources\n\n\nclass PersonResource(resources.BaseResource):\n    class Meta:\n        name = 'Person'\n        resource_name = 'people'\n        identifier = 'url'\n        attributes = (\n            'name',\n            'birth_year',\n            'eye_color',\n            'gender',\n            'height',\n            'mass',\n            'url',\n        )\n        valid_status_codes = (\n            200,\n        )\n        methods = (\n            'get',\n        )\n\n\n\n\nEverything in Beckett is defined using Python classes and Meta classes. The definitions are then used by Beckett to construct the interface for communicating with the HTTP API for you. This is what we mean when we say Beckett is \n\"convention-based\"\n - it understands RESTful HTTP APIs by default and will adapt the definitions you write to fit within it.\n\n\nIn the example above we've defined a series of properties for this resource. Let's talk about each of them now to understand what they mean:\n\n\n\n\nname\n: This string will be used by Beckett in Python \n__repr__\n and \n__unicode__\n methods.\n\n\nresource_name\n: Sometimes the resource name differs slightly because the plural of a resource is different from the singular. RESTful HTTP APIs conventionally use plural names in URIs. This property is not required and Beckett will try to guess the plural name of the \nname\n property. In this case it will guess \npersons\n, which doesn't fit with our API. Luckily, the \nresource_name\n attribute is provided so we can avoid this behaviour if we want.\n\n\nidentifier\n: This attribute is used to determine the unique identifying attribute of the resource. It will be used in Python \n__repr__\n and \n__unicode__\n methods.\n\n\nattributes\n: This is a tuple of strings, declaring the attributes you want to see from the resource when it is generated. If you look at \nan example API response\n from Swapi, you will see these attributes listed. You can read more about \nResource attributes here\n. You can use this to white-list specific attributes.\n\n\nvalid_status_codes\n: This is a tuple of integers, declaring the HTTP response codes you consider \"valid\". Some HTTP APIs behave differently and certain responses are expected, such as \n202\n or \n404\n. If an HTTP response code is received that is not in the list, Beckett will raise an exception.\n\n\nmethods\n: This is a tuple of strings, declaring the HTTP methods that can be used with this resource. Beckett will use this tuple to generate python methods.\n\n\n\n\nYou can read more about resources on the \nResources\n page.\n\n\nClient\n\n\nNow that we've got our Resource created, let's build a Client to start using it.\n\n\n\n# my_client.py\nfrom .my_resources import PersonResource\n\nclass StarWarsClient(clients.BaseClient):\n    class Meta:\n        name = 'Star Wars API Client'\n        base_url = 'https://swapi.co/api/'\n        resources = (\n            PersonResource,\n        )\n\n\n\n\nJust like the Resource, we can declare a bunch of properties on our Client:\n\n\n\n\nname\n - This property will be used in HTTP headers as well as in \n__repr__\n and \n__unicode__\n methods.\n\n\nbase_url\n - This is the base url for the API. Beckett will use this to construct the URL when making HTTP requests.\n\n\nresources\n - This is a tuple of \nResource\n classes that you want the client to communicate with.\n\n\n\n\nYou can read more about clients on the \nClients\n page.\n\n\nMake HTTP calls!\n\n\nWe can now start calling the API!\n\n\nfrom .my_resources import PersonResource\nfrom .my_client import StarWarsClient\n\nswapi = StarWarsClient()\nresults_list = swapi.get_person(uid=1)\n\nperson = results_list[0]\n\nisinstance(result, PersonResource)\n>>> True\nperson.name\n'Luke Skywalker'\n\n\n\n\nBeckett has generated a \nget_person\n method because it has read the \nPersonResource\n and seen which HTTP methods it wants. This method conventionally takes a single parameter \nuid\n. These generated methods also except arbitrary keyword arguments for customisation. You can read more about this in the \nadvanced\n section.\n\n\nThe response is a list of \nPersonResource\n instances. Beckett infers the JSON response and transforms the JSON values into attributes on each instance, so we can query \nperson.name\n.\n\n\nFurther reading\n\n\nThis guide has demonstrated the basics of Beckett, using most of the conventionally-based stuff. However, most HTTP APIs are not always perfectly RESTful. Luckily, Beckett is designed to be flexible enough to provide ways to support other HTTP APIs, we recommend reading the \nadvanced\n guide if you're looking to modify Beckett's behaviour.",
            "title": "Getting Started"
        },
        {
            "location": "/intro/#getting-started",
            "text": "Beckett can be installed using  pip :  pip install beckett",
            "title": "Getting Started"
        },
        {
            "location": "/intro/#a-basic-client",
            "text": "Let's get to grips with Beckett by writing a basic client for communicating with  Swapi , the Star Wars API.",
            "title": "A Basic Client"
        },
        {
            "location": "/intro/#resources",
            "text": "The first thing we'll need to do is declare a  Resource . Swapi has  many resources , but let's create a resource for just  People :  # my_resources.py\nfrom beckett import resources\n\n\nclass PersonResource(resources.BaseResource):\n    class Meta:\n        name = 'Person'\n        resource_name = 'people'\n        identifier = 'url'\n        attributes = (\n            'name',\n            'birth_year',\n            'eye_color',\n            'gender',\n            'height',\n            'mass',\n            'url',\n        )\n        valid_status_codes = (\n            200,\n        )\n        methods = (\n            'get',\n        )  Everything in Beckett is defined using Python classes and Meta classes. The definitions are then used by Beckett to construct the interface for communicating with the HTTP API for you. This is what we mean when we say Beckett is  \"convention-based\"  - it understands RESTful HTTP APIs by default and will adapt the definitions you write to fit within it.  In the example above we've defined a series of properties for this resource. Let's talk about each of them now to understand what they mean:   name : This string will be used by Beckett in Python  __repr__  and  __unicode__  methods.  resource_name : Sometimes the resource name differs slightly because the plural of a resource is different from the singular. RESTful HTTP APIs conventionally use plural names in URIs. This property is not required and Beckett will try to guess the plural name of the  name  property. In this case it will guess  persons , which doesn't fit with our API. Luckily, the  resource_name  attribute is provided so we can avoid this behaviour if we want.  identifier : This attribute is used to determine the unique identifying attribute of the resource. It will be used in Python  __repr__  and  __unicode__  methods.  attributes : This is a tuple of strings, declaring the attributes you want to see from the resource when it is generated. If you look at  an example API response  from Swapi, you will see these attributes listed. You can read more about  Resource attributes here . You can use this to white-list specific attributes.  valid_status_codes : This is a tuple of integers, declaring the HTTP response codes you consider \"valid\". Some HTTP APIs behave differently and certain responses are expected, such as  202  or  404 . If an HTTP response code is received that is not in the list, Beckett will raise an exception.  methods : This is a tuple of strings, declaring the HTTP methods that can be used with this resource. Beckett will use this tuple to generate python methods.   You can read more about resources on the  Resources  page.",
            "title": "Resources"
        },
        {
            "location": "/intro/#client",
            "text": "Now that we've got our Resource created, let's build a Client to start using it.  \n# my_client.py\nfrom .my_resources import PersonResource\n\nclass StarWarsClient(clients.BaseClient):\n    class Meta:\n        name = 'Star Wars API Client'\n        base_url = 'https://swapi.co/api/'\n        resources = (\n            PersonResource,\n        )  Just like the Resource, we can declare a bunch of properties on our Client:   name  - This property will be used in HTTP headers as well as in  __repr__  and  __unicode__  methods.  base_url  - This is the base url for the API. Beckett will use this to construct the URL when making HTTP requests.  resources  - This is a tuple of  Resource  classes that you want the client to communicate with.   You can read more about clients on the  Clients  page.",
            "title": "Client"
        },
        {
            "location": "/intro/#make-http-calls",
            "text": "We can now start calling the API!  from .my_resources import PersonResource\nfrom .my_client import StarWarsClient\n\nswapi = StarWarsClient()\nresults_list = swapi.get_person(uid=1)\n\nperson = results_list[0]\n\nisinstance(result, PersonResource)\n>>> True\nperson.name\n'Luke Skywalker'  Beckett has generated a  get_person  method because it has read the  PersonResource  and seen which HTTP methods it wants. This method conventionally takes a single parameter  uid . These generated methods also except arbitrary keyword arguments for customisation. You can read more about this in the  advanced  section.  The response is a list of  PersonResource  instances. Beckett infers the JSON response and transforms the JSON values into attributes on each instance, so we can query  person.name .",
            "title": "Make HTTP calls!"
        },
        {
            "location": "/intro/#further-reading",
            "text": "This guide has demonstrated the basics of Beckett, using most of the conventionally-based stuff. However, most HTTP APIs are not always perfectly RESTful. Luckily, Beckett is designed to be flexible enough to provide ways to support other HTTP APIs, we recommend reading the  advanced  guide if you're looking to modify Beckett's behaviour.",
            "title": "Further reading"
        },
        {
            "location": "/resources/",
            "text": "Resources are models relating to individual resources in an HTTP API.\n\n\nclass BaseResource\n\n\nA simple representation of a resource.\n\n\nExample:\n\n\n# my_resources.py\nfrom beckett import resources\n\n\nclass PersonResource(resources.BaseResource):\n    class Meta:\n        name = 'Person'\n        resource_name = 'people'\n        identifier = 'url'\n        attributes = (\n            'name',\n            'birth_year',\n            'eye_color',\n            'gender',\n            'height',\n            'mass',\n            'url',\n        )\n        valid_status_codes = (\n            200,\n        )\n        methods = (\n            'get',\n        )\n\n\n\n\nMeta Attributes\n\n\n\n\n\n\n\n\nAttribute\n\n\nRequired\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nYes\n\n\nString\n\n\nThe name of this resource instance. Usually a singular noun.\n\n\n\n\n\n\nresource_name\n\n\nNo\n\n\nString\n\n\nThe name of this resource used in the url. Usually a plural noun. If not set, we'll attempt to make a pluralised version of the \nname\n attribute.\n\n\n\n\n\n\nidentifier\n\n\nYes\n\n\nInt/String\n\n\nThe key attribute that can be used to identify this attribute. Used when referring to related resources.\n\n\n\n\n\n\nattributes\n\n\nYes\n\n\nTuple of Strings\n\n\nA tuple list of strings, referring to the key attributes that you want to populate the resource instances with. You can use this for whitelisting and versioning changes in your API.\n\n\n\n\n\n\nvalid_status_codes\n\n\nNo\n\n\nTuple of Ints\n\n\nA tuple list of integers, referring to the HTTP status codes that are considered \"acceptable\" when communicating with this resource. If a status code is received that does not match this set, an error will be raised.\n\n\n\n\n\n\nmethods\n\n\nNo\n\n\nTuple of Strings\n\n\nA tuple list of strings, referring to the HTTP methods that can be used with this resource. For each method, a python method will be generated on the client that registers this resource.\n\n\n\n\n\n\npagination_key\n\n\nNo\n\n\nString\n\n\nThe key used to look up paginated responses. The value of this key in an API response will be rendered into instances of this resource. See \nPagination\n for more help.\n\n\n\n\n\n\n\n\nCustomisable Methods\n\n\nThe BaseResource has methods that can be subclassed and customised:\n\n\n\n\nBaseResource.get_url\n\n\n\n\nURL Generation\n\n\nBeckett attempts to auto generate URLs based on good RESTful style URI schemes. If you do nothing to manipulate the URLs, Beckett will call the following URLs for the related HTTP Methods:\n\n\n\n\n\n\n\n\nMethod\n\n\nURI Structure\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nGET\n\n\nClient.Meta.base_url/Resource.Meta.plural_name/uid\n\n\nhttp://myapi.com/api/products/1/\n\n\n\n\n\n\nPUT\n\n\nClient.Meta.base_url/Resource.Meta.plural_name/uid\n\n\nhttp://myapi.com/api/products/1/\n\n\n\n\n\n\nPOST\n\n\nClient.Meta.base_url/Resource.Meta.plural_name\n\n\nhttp://myapi.com/api/products\n\n\n\n\n\n\nPATCH\n\n\nClient.Meta.base_url/Resource.Meta.plural_name/uid\n\n\nhttp://myapi.com/api/products/1/\n\n\n\n\n\n\nDELETE\n\n\nClient.Meta.base_url/Resource.Meta.plural_name/uid\n\n\nhttp://myapi.com/api/products/1/\n\n\n\n\n\n\n\n\nURL structures can be completely modified by subclassing the \nget_url\n method on Resources. See \ncustomising resource urls\n for more information.\n\n\nAssigning properties\n\n\nproperties are assigned to the generated class instances based on the JSON data returned. Consider the following JSON data:\n\n\n{\n    \"name\": \"luke skywalker\",\n    \"age\": 18,\n    \"url\": \"https://swapi.co/api/people/1\"\n}\n\n\n\n\nIf our resource declared the following \nattributes\n list:\n\n\nattributes = (\n    'name',\n    'age',\n)\n\n\n\n\nThen the generated instance will have the following properties:\n\n\nperson.name\n>>> 'luke skywalker'\nperson.age\n>>> 18\n\n\n\n\nThe \nurl\n property will not be added.\n\n\nBeckett will try to determine the type of the property from the JSON type. Beckett does not currently support complex type assignments.\n\n\nclass HypermediaResource\n\n\nA simple representation of a resource that supports hypermedia links to related resources.\n\n\nExample:\n\n\n# myresources.py\nfrom beckett.resources import HypermediaResource\n\nclass Designer(HypermediaResource):\n    class Meta(HypermediaResource.Meta):\n        name = 'Designer'\n        identifier = 'slug'\n        attributes = (\n            'slug',\n            'name',\n        )\n        methods = (\n            'get',\n        )\n        # Additional required attributes\n        base_url = 'http://myapi.com/api'\n        related_resources = ()\n\n\nclass Product(HypermediaResource):\n\n    class Meta(HypermediaResource.Meta):\n        name = 'Product'\n        identifier = 'slug'\n        attributes = (\n            'slug',\n            'name',\n            'price',\n            'discount'\n        )\n        methods = (\n            'get',\n        )\n        # Additional required attributes\n        base_url = 'http://myapi.com/api'\n        related_resources = (\n            Designer,\n        )\n\n\n\n\n\nUsage:\n\n\n# Note: Data will usually come straight from the client method\n>>> data = {'name': 'Tasty product', 'slug': 'sluggy', 'designer': 'http://myapi.com/api/designers/some-designer'}\n>>> product = Product(**data)\n>>> product.get_designer(uid='some-designer')\n<Designer | Some Designer>\n\n\n\n\nMeta Attributes\n\n\nHypermediaResource has two additional, required, attributes that are essential for making hypermedia work\n\n\n\n\n\n\n\n\nAttribute\n\n\nRequired\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbase_url\n\n\nYes\n\n\nString\n\n\nThe base url of this resource\n\n\n\n\n\n\nrelated_resources\n\n\nYes\n\n\nTuple of classes\n\n\nA tuple of classes that are related to this resource, and should be expected in the JSON response from the API.\n\n\n\n\n\n\n\n\nCustomisable Methods\n\n\nThe HypermediaResource has methods that can be subclassed and customised:\n\n\n\n\nHypermediaResource.get_url\n\n\nHypermediaResource.get_http_headers\n\n\nHypermediaResource.prepare_http_request",
            "title": "Resources"
        },
        {
            "location": "/resources/#class-baseresource",
            "text": "A simple representation of a resource.  Example:  # my_resources.py\nfrom beckett import resources\n\n\nclass PersonResource(resources.BaseResource):\n    class Meta:\n        name = 'Person'\n        resource_name = 'people'\n        identifier = 'url'\n        attributes = (\n            'name',\n            'birth_year',\n            'eye_color',\n            'gender',\n            'height',\n            'mass',\n            'url',\n        )\n        valid_status_codes = (\n            200,\n        )\n        methods = (\n            'get',\n        )",
            "title": "class BaseResource"
        },
        {
            "location": "/resources/#meta-attributes",
            "text": "Attribute  Required  Type  Description      name  Yes  String  The name of this resource instance. Usually a singular noun.    resource_name  No  String  The name of this resource used in the url. Usually a plural noun. If not set, we'll attempt to make a pluralised version of the  name  attribute.    identifier  Yes  Int/String  The key attribute that can be used to identify this attribute. Used when referring to related resources.    attributes  Yes  Tuple of Strings  A tuple list of strings, referring to the key attributes that you want to populate the resource instances with. You can use this for whitelisting and versioning changes in your API.    valid_status_codes  No  Tuple of Ints  A tuple list of integers, referring to the HTTP status codes that are considered \"acceptable\" when communicating with this resource. If a status code is received that does not match this set, an error will be raised.    methods  No  Tuple of Strings  A tuple list of strings, referring to the HTTP methods that can be used with this resource. For each method, a python method will be generated on the client that registers this resource.    pagination_key  No  String  The key used to look up paginated responses. The value of this key in an API response will be rendered into instances of this resource. See  Pagination  for more help.",
            "title": "Meta Attributes"
        },
        {
            "location": "/resources/#customisable-methods",
            "text": "The BaseResource has methods that can be subclassed and customised:   BaseResource.get_url",
            "title": "Customisable Methods"
        },
        {
            "location": "/resources/#url-generation",
            "text": "Beckett attempts to auto generate URLs based on good RESTful style URI schemes. If you do nothing to manipulate the URLs, Beckett will call the following URLs for the related HTTP Methods:     Method  URI Structure  Example      GET  Client.Meta.base_url/Resource.Meta.plural_name/uid  http://myapi.com/api/products/1/    PUT  Client.Meta.base_url/Resource.Meta.plural_name/uid  http://myapi.com/api/products/1/    POST  Client.Meta.base_url/Resource.Meta.plural_name  http://myapi.com/api/products    PATCH  Client.Meta.base_url/Resource.Meta.plural_name/uid  http://myapi.com/api/products/1/    DELETE  Client.Meta.base_url/Resource.Meta.plural_name/uid  http://myapi.com/api/products/1/     URL structures can be completely modified by subclassing the  get_url  method on Resources. See  customising resource urls  for more information.",
            "title": "URL Generation"
        },
        {
            "location": "/resources/#assigning-properties",
            "text": "properties are assigned to the generated class instances based on the JSON data returned. Consider the following JSON data:  {\n    \"name\": \"luke skywalker\",\n    \"age\": 18,\n    \"url\": \"https://swapi.co/api/people/1\"\n}  If our resource declared the following  attributes  list:  attributes = (\n    'name',\n    'age',\n)  Then the generated instance will have the following properties:  person.name\n>>> 'luke skywalker'\nperson.age\n>>> 18  The  url  property will not be added.  Beckett will try to determine the type of the property from the JSON type. Beckett does not currently support complex type assignments.",
            "title": "Assigning properties"
        },
        {
            "location": "/resources/#class-hypermediaresource",
            "text": "A simple representation of a resource that supports hypermedia links to related resources.  Example:  # myresources.py\nfrom beckett.resources import HypermediaResource\n\nclass Designer(HypermediaResource):\n    class Meta(HypermediaResource.Meta):\n        name = 'Designer'\n        identifier = 'slug'\n        attributes = (\n            'slug',\n            'name',\n        )\n        methods = (\n            'get',\n        )\n        # Additional required attributes\n        base_url = 'http://myapi.com/api'\n        related_resources = ()\n\n\nclass Product(HypermediaResource):\n\n    class Meta(HypermediaResource.Meta):\n        name = 'Product'\n        identifier = 'slug'\n        attributes = (\n            'slug',\n            'name',\n            'price',\n            'discount'\n        )\n        methods = (\n            'get',\n        )\n        # Additional required attributes\n        base_url = 'http://myapi.com/api'\n        related_resources = (\n            Designer,\n        )  Usage:  # Note: Data will usually come straight from the client method\n>>> data = {'name': 'Tasty product', 'slug': 'sluggy', 'designer': 'http://myapi.com/api/designers/some-designer'}\n>>> product = Product(**data)\n>>> product.get_designer(uid='some-designer')\n<Designer | Some Designer>",
            "title": "class HypermediaResource"
        },
        {
            "location": "/resources/#meta-attributes_1",
            "text": "HypermediaResource has two additional, required, attributes that are essential for making hypermedia work     Attribute  Required  Type  Description      base_url  Yes  String  The base url of this resource    related_resources  Yes  Tuple of classes  A tuple of classes that are related to this resource, and should be expected in the JSON response from the API.",
            "title": "Meta Attributes"
        },
        {
            "location": "/resources/#customisable-methods_1",
            "text": "The HypermediaResource has methods that can be subclassed and customised:   HypermediaResource.get_url  HypermediaResource.get_http_headers  HypermediaResource.prepare_http_request",
            "title": "Customisable Methods"
        },
        {
            "location": "/clients/",
            "text": "Clients are models that wrap the interaction with an API service.\n\n\nclass BaseClients\n\n\nA simple HTTP API client.\n\n\nExample:\n\n\n# my_client.py\n\nfrom .my_resources import PersonResource\n\nclass StarWarsClient(clients.BaseClient):\n    class Meta:\n        name = 'Star Wars API Client'\n        base_url = 'https://swapi.co/api/'\n        resources = (\n            PersonResource,\n        )\n\n\n\n\nUsage:\n\n\nfrom .my_resources import PersonResource\nfrom .my_client import StarWarsClient\n\nswapi = StarWarsClient()\nresults_list = swapi.get_person(uid=1)\n\nperson = results_list[0]\n\nisinstance(result, PersonResource)\n>>> True\nperson.name\n'Luke Skywalker'\n\n\n\n\nMeta Attributes\n\n\n\n\n\n\n\n\nAttribute\n\n\nRequired\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbase_url\n\n\nYes\n\n\nString\n\n\nThe Base URL for the HTTP API Service.\n\n\n\n\n\n\nname\n\n\nYes\n\n\nString\n\n\nThe name of this client.\n\n\n\n\n\n\nresources\n\n\nYes\n\n\nTuple of Resource objects\n\n\nA tuple of \nResource\n classes that you want to register with this client\n\n\n\n\n\n\n\n\nGenerated Methods\n\n\nA number of methods are generated on the client for each resource that is registered.\n\n\nBased on the \nmethods\n in a \nResource\n, the following python methods are created:\n\n\n\n\n\n\n\n\nMethod\n\n\nHTTP method\n\n\nRequired Arguments\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nget\n\n\nGET\n\n\nuid\n\n\nget_product\n\n\n\n\n\n\npost\n\n\nPOST\n\n\ndata\n\n\npost_product\n\n\n\n\n\n\nput\n\n\nPUT\n\n\nuid, data\n\n\nput_product\n\n\n\n\n\n\npatch\n\n\nPATCH\n\n\nuid, data\n\n\npatch_product\n\n\n\n\n\n\ndelete\n\n\nDELETE\n\n\nuid\n\n\ndelete_product\n\n\n\n\n\n\n\n\nEach method has it's own required arguments:\n\n\n\n\n\n\n\n\nArgument\n\n\nType\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nuid\n\n\nstring or int\n\n\n1\n or \n'some_slug'\n\n\n\n\n\n\ndata\n\n\ndictionary\n\n\n{'name': 'product', 'slug': 'some_slug'}\n\n\n\n\n\n\n\n\nCustomisable Methods\n\n\nThe BaseClient has methods that can be subclassed and customised:\n\n\n\n\nBaseClient.get_http_headers\n\n\nBaseClient.prepare_http_request\n\n\n\n\nPassing additional keyword arguments\n\n\nAdditional keyword arguments can be passed into the auto-generated methods and will appear in the following methods were applicable:\n\n\nBaseResource.get_url\nBaseClient.get_http_headers\nBaseClient.prepare_http_request\nHypermediaResource.get_http_headers\nHypermediaResource.prepare_http_request\n\n\n\n\nFor example:\n\n\nclient.get_product(product_id=123, product_country='US')\n\n\n\n\nThis allows for some flexibility when customising these methods. For more information on how to customise these methods, please read the \nadvanced\n guide.",
            "title": "Clients"
        },
        {
            "location": "/clients/#class-baseclients",
            "text": "A simple HTTP API client.  Example:  # my_client.py\n\nfrom .my_resources import PersonResource\n\nclass StarWarsClient(clients.BaseClient):\n    class Meta:\n        name = 'Star Wars API Client'\n        base_url = 'https://swapi.co/api/'\n        resources = (\n            PersonResource,\n        )  Usage:  from .my_resources import PersonResource\nfrom .my_client import StarWarsClient\n\nswapi = StarWarsClient()\nresults_list = swapi.get_person(uid=1)\n\nperson = results_list[0]\n\nisinstance(result, PersonResource)\n>>> True\nperson.name\n'Luke Skywalker'",
            "title": "class BaseClients"
        },
        {
            "location": "/clients/#meta-attributes",
            "text": "Attribute  Required  Type  Description      base_url  Yes  String  The Base URL for the HTTP API Service.    name  Yes  String  The name of this client.    resources  Yes  Tuple of Resource objects  A tuple of  Resource  classes that you want to register with this client",
            "title": "Meta Attributes"
        },
        {
            "location": "/clients/#generated-methods",
            "text": "A number of methods are generated on the client for each resource that is registered.  Based on the  methods  in a  Resource , the following python methods are created:     Method  HTTP method  Required Arguments  Example      get  GET  uid  get_product    post  POST  data  post_product    put  PUT  uid, data  put_product    patch  PATCH  uid, data  patch_product    delete  DELETE  uid  delete_product     Each method has it's own required arguments:     Argument  Type  Example      uid  string or int  1  or  'some_slug'    data  dictionary  {'name': 'product', 'slug': 'some_slug'}",
            "title": "Generated Methods"
        },
        {
            "location": "/clients/#customisable-methods",
            "text": "The BaseClient has methods that can be subclassed and customised:   BaseClient.get_http_headers  BaseClient.prepare_http_request",
            "title": "Customisable Methods"
        },
        {
            "location": "/clients/#passing-additional-keyword-arguments",
            "text": "Additional keyword arguments can be passed into the auto-generated methods and will appear in the following methods were applicable:  BaseResource.get_url\nBaseClient.get_http_headers\nBaseClient.prepare_http_request\nHypermediaResource.get_http_headers\nHypermediaResource.prepare_http_request  For example:  client.get_product(product_id=123, product_country='US')  This allows for some flexibility when customising these methods. For more information on how to customise these methods, please read the  advanced  guide.",
            "title": "Passing additional keyword arguments"
        },
        {
            "location": "/advanced/",
            "text": "Customising Resource URLs\n\n\nIf you have domain-specific URLs you can modify them individually per Resource.\n\n\nIf we have a resource that requires a URL structure like so:\n\n\nhttps://myapi.com/api/v1/product?id=123&country=GB\n\n\n\n\nWhich would require:\n\n\n\n\nThe URL to accept an \nid\n query parameter\n\n\nAn additional \ncountry\n parameter\n\n\n\n\nThen we can customise our \nProductResource\n like so:\n\n\nclass Product(BaseResource):\n\n    class Meta(BaseResource.Meta):\n        name = 'Product'\n        identifier = 'slug'\n        attributes = (\n            'slug',\n        )\n        methods = (\n            'get',\n        )\n\n    @classmethod\n    def get_url(cls, url, uid, **kwargs):\n        \"\"\"\n        Our customised URL.\n        \"\"\"\n        return '{}/products/?id={}&country={}'.format(\n            url,\n            uid,\n            kwargs.get('country')\n        )\n\n\n\n\nWhen we go to use the resource in our client we simply call the \nget_method\n with additional parameters:\n\n\nclient.get_product(uid=1, country='GB')\n>>> <Product | 1>\n\n\n\n\nCustomise HTTP headers\n\n\nYou can customise HTTP headers by subclassing the \nBaseClient.get_http_headers\n method. For example:\n\n\nclass MyClient(clients.BaseClient):\n\n    class Meta:\n        ...\n\n    def get_http_headers(self, client_name, method_name, **kwargs):\n        headers = super(MyClient, self).get_http_headers(client_name, method_name, **kwargs)\n        headers['mission'] = \"I'm just trying to get home.\"\n        return headers\n\n\n\n\n\nModify HTTP Request\n\n\nYou can modify the prepared HTTP request before it is sent. You might want to do this to modify\nsession data or attach SSL certificates. For example:\n\n\nclass MyClient(clients.BaseClient):\n\n    class Meta:\n        ...\n\n    def prepare_http_request(self, method_type, params, **kwargs):\n        prepared_request = super(MyClient, self).prepare_http_request(method_type, params, **kwargs)\n        # Your modifications here\n        return prepared_request\n\n\n\n\n\nPagination\n\n\nPagination is supported by Beckett. Because there are many forms of pagination, we recommend customising the \nget_url\n method on your resource, similarly to the \nexample above\n. Because all keyword arguments are passed to this method, you can call the page like so:\n\n\nresources = client.get_resource(page=2)\n\n\n\n\nand format the URL in the code like so:\n\n\n@classmethod\ndef get_url(cls, url, uid, **kwargs):\n    if kwargs.get('page'):\n        return '{}?page={}'.format(\n            url,\n            kwargs.get('page')\n        )\n\n\n\n\nWhen rendering responses into your resource instances, Beckett will perform the following steps:\n\n\n\n\nIs the response a list? If yes - render each item in the list as a Resource.\n\n\nIs the \npagination_key\n value in this resource declared? If yes, look it up in the response object and render that list into resources.\n\n\nAttempt to render the whole response as a single resource instance.\n\n\n\n\npagination_key\n\n\nIn your Resource, declare a pagination_key attribute:\n\n\n\n```python\nclass Product(BaseResource):\n\n    class Meta(BaseResource.Meta):\n        ...\n        pagination_key = 'objects'\n\n\n\n\nTo correspond with a paginated API response like so:\n\n\n{\n    \"next\": \"http://myapi.com/api/resources?page=2\",\n    \"objects\": [\n        {\n            \"name\": \"Resource one\"\n        },\n        {\n            \"name\": \"Resource two\"\n        }\n    ]\n}",
            "title": "Advanced Features"
        },
        {
            "location": "/advanced/#customising-resource-urls",
            "text": "If you have domain-specific URLs you can modify them individually per Resource.  If we have a resource that requires a URL structure like so:  https://myapi.com/api/v1/product?id=123&country=GB  Which would require:   The URL to accept an  id  query parameter  An additional  country  parameter   Then we can customise our  ProductResource  like so:  class Product(BaseResource):\n\n    class Meta(BaseResource.Meta):\n        name = 'Product'\n        identifier = 'slug'\n        attributes = (\n            'slug',\n        )\n        methods = (\n            'get',\n        )\n\n    @classmethod\n    def get_url(cls, url, uid, **kwargs):\n        \"\"\"\n        Our customised URL.\n        \"\"\"\n        return '{}/products/?id={}&country={}'.format(\n            url,\n            uid,\n            kwargs.get('country')\n        )  When we go to use the resource in our client we simply call the  get_method  with additional parameters:  client.get_product(uid=1, country='GB')\n>>> <Product | 1>",
            "title": "Customising Resource URLs"
        },
        {
            "location": "/advanced/#customise-http-headers",
            "text": "You can customise HTTP headers by subclassing the  BaseClient.get_http_headers  method. For example:  class MyClient(clients.BaseClient):\n\n    class Meta:\n        ...\n\n    def get_http_headers(self, client_name, method_name, **kwargs):\n        headers = super(MyClient, self).get_http_headers(client_name, method_name, **kwargs)\n        headers['mission'] = \"I'm just trying to get home.\"\n        return headers",
            "title": "Customise HTTP headers"
        },
        {
            "location": "/advanced/#modify-http-request",
            "text": "You can modify the prepared HTTP request before it is sent. You might want to do this to modify\nsession data or attach SSL certificates. For example:  class MyClient(clients.BaseClient):\n\n    class Meta:\n        ...\n\n    def prepare_http_request(self, method_type, params, **kwargs):\n        prepared_request = super(MyClient, self).prepare_http_request(method_type, params, **kwargs)\n        # Your modifications here\n        return prepared_request",
            "title": "Modify HTTP Request"
        },
        {
            "location": "/advanced/#pagination",
            "text": "Pagination is supported by Beckett. Because there are many forms of pagination, we recommend customising the  get_url  method on your resource, similarly to the  example above . Because all keyword arguments are passed to this method, you can call the page like so:  resources = client.get_resource(page=2)  and format the URL in the code like so:  @classmethod\ndef get_url(cls, url, uid, **kwargs):\n    if kwargs.get('page'):\n        return '{}?page={}'.format(\n            url,\n            kwargs.get('page')\n        )  When rendering responses into your resource instances, Beckett will perform the following steps:   Is the response a list? If yes - render each item in the list as a Resource.  Is the  pagination_key  value in this resource declared? If yes, look it up in the response object and render that list into resources.  Attempt to render the whole response as a single resource instance.",
            "title": "Pagination"
        },
        {
            "location": "/advanced/#pagination_key",
            "text": "In your Resource, declare a pagination_key attribute:  \n```python\nclass Product(BaseResource):\n\n    class Meta(BaseResource.Meta):\n        ...\n        pagination_key = 'objects'  To correspond with a paginated API response like so:  {\n    \"next\": \"http://myapi.com/api/resources?page=2\",\n    \"objects\": [\n        {\n            \"name\": \"Resource one\"\n        },\n        {\n            \"name\": \"Resource two\"\n        }\n    ]\n}",
            "title": "pagination_key"
        },
        {
            "location": "/exceptions/",
            "text": "BadURLException\n\n\nAn Invalid URL was parsed.\n\n\nThis usually happens when customising the \nget_url\n method.\n\n\nInvalidStatusCodeError\n\n\nAn invalid status code was returned for this resource.\n\n\nThe valid_status_codes tuple defined on resources determines which status codes are deemed \"valid\" when talking to the API.\n\n\nMissingUidException\n\n\nA uid attribute was missing!\n\n\nIf no \nuid\n attribute is supplied, this exception will raise.",
            "title": "Exceptions"
        },
        {
            "location": "/exceptions/#badurlexception",
            "text": "An Invalid URL was parsed.  This usually happens when customising the  get_url  method.",
            "title": "BadURLException"
        },
        {
            "location": "/exceptions/#invalidstatuscodeerror",
            "text": "An invalid status code was returned for this resource.  The valid_status_codes tuple defined on resources determines which status codes are deemed \"valid\" when talking to the API.",
            "title": "InvalidStatusCodeError"
        },
        {
            "location": "/exceptions/#missinguidexception",
            "text": "A uid attribute was missing!  If no  uid  attribute is supplied, this exception will raise.",
            "title": "MissingUidException"
        }
    ]
}