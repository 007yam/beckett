{
    "docs": [
        {
            "location": "/",
            "text": "\ud83d\udcab Beckett\n\n\nHypermedia API Client Framework\n\n\n\n\nBeckett is a convention-based framework for building Python interfaces around HTTP APIs.\n\n\n\n\n\n\n\n\n\n\n\ud83d\udcd6 Features\n\n\n\n\nDefine your API client in Python instead of a data serialization language.\n\n\nEncourages good HTTP and REST practices without being too strict.\n\n\nResources are transformed into typed instances - no more raw dictionaries!\n\n\nAutomatic URL routing for RESTful interaction to your resources.\n\n\nHypermedia relationship links are automagically resolved into python methods.\n\n\nSupports hypermedia response formats such as JSONAPI and HAL. [IN DEV]\n\n\nWorks out of the box, but each resource is completely configurable. [IN DEV]\n\n\n\n\n\ud83c\udfd7 Status\n\n\nBeckett is currently under \nmajor development\n and usage in critical projects is not recommended.\n\n\n\ud83c\udfa5 Credits\n\n\nThis package was created with \nCookiecutter\n.\n\n\nWe use \nPython Requests\n for talking HTTP.\n\n\nFree software: \nISC license",
            "title": "Home"
        },
        {
            "location": "/#beckett",
            "text": "Hypermedia API Client Framework   Beckett is a convention-based framework for building Python interfaces around HTTP APIs.",
            "title": "\ud83d\udcab Beckett"
        },
        {
            "location": "/#features",
            "text": "Define your API client in Python instead of a data serialization language.  Encourages good HTTP and REST practices without being too strict.  Resources are transformed into typed instances - no more raw dictionaries!  Automatic URL routing for RESTful interaction to your resources.  Hypermedia relationship links are automagically resolved into python methods.  Supports hypermedia response formats such as JSONAPI and HAL. [IN DEV]  Works out of the box, but each resource is completely configurable. [IN DEV]",
            "title": "\ud83d\udcd6 Features"
        },
        {
            "location": "/#status",
            "text": "Beckett is currently under  major development  and usage in critical projects is not recommended.",
            "title": "\ud83c\udfd7 Status"
        },
        {
            "location": "/#credits",
            "text": "This package was created with  Cookiecutter .  We use  Python Requests  for talking HTTP.  Free software:  ISC license",
            "title": "\ud83c\udfa5 Credits"
        },
        {
            "location": "/intro/",
            "text": "Getting Started\n\n\nBeckett can be installed using \npip\n:\n\n\npip install beckett\n\n\n\n\nOnce installed, use the \nResources\n and \nClients\n documentation, or read through the concepts tutorial below to familiarise yourself with how Beckett works.\n\n\nConcepts\n\n\nBeckett has two key base models that you'll need to configure in order to get started: \nResources\n and \nClients\n.\n\n\nWe'll using the following snippet of code to explain the basics concepts of Beckett:\n\n\n# my_client.py\nfrom beckett import clients, resources\n\n\nclass PokemonResource(resources.BaseResource):\n    class Meta(resources.BaseResource.Meta):\n        name = 'Pokemon'\n        identifier = 'id'\n        attributes = (\n            'id',\n            'name',\n        )\n        methods = (\n            'get',\n        )\n\n\nclass PokemonClient(clients.BaseClient):\n    class Meta(clients.BaseClient.Meta):\n        base_url = 'https://pokeapi.co/api/v1/'\n        resources = (\n            PokemonResource,\n        )\n\n\n\n\nResources\n\n\nA \nResource\n object represents a single resource in your API service:\n\n\nResources have a series of attributes in their \nMeta\n class. These define the attributes and behaviour of a resource.\n\n\nIn this instance, we are naming our resource with the \nname\n attribute. We're defining a unique \nidentifier\n\nattribute to use when querying this resource, and setting a white list of \nattributes\n that we want to display on this resource.\n\n\nA full list of available attributes can be found on the \nResources\n page.\n\n\nClients\n\n\nA typical Beckett-based API client only needs one \nClient\n instance. However, many clients can be used for versioning.\n\n\nClients can be configured using \nMeta\n class attributes, and inherits the defaults from the \nBaseClient\n.\n\n\nIn this instance we're setting the \nbase_url\n of the API, as well as a list of \nresources\n that this API supports.\n\n\nA list of available attributes can be found on the \nClients\n page.\n\n\nExample Usage\n\n\nWe can now start calling the API!\n\n\nfrom my_client import PokemonClient\n\nmy_client = PokemonClient()\nresult = my_client.get_pokemon(1)[0]\n\nisinstance(result, PokemonResource)\n>>> True\nresult.name\n'Bulbasaur'\n\n\n\n\nOur client generates a collection of methods for every registered resource and understands how to properly call each method.\n\n\nA lot of stuff is automatically generated here for us, so let's break it down and go through it line by line:\n\n\nmy_client.get_pokemon(uid=1)\n\n\n\n\nThe \nPokemonClient\n will look at \nPokemonResource\n \nmethods\n attribute to determine what HTTP methods are available on it. The default is:\n\n\nmethods = (\n        'get'\n    )\n\n\n\n\nThe \nPokemonResource\n will also set the resource name as the lower-case of the \nname\n attribute. However, if this resource is called something different in the API we can set it ourselves in \nPokemonResource\n:\n\n\nresource = 'pokemons'\n\n\n\n\nThe \n1\n will be used by the \nidentifier\n attribute on \nPokemonResource\n to help construct the URL when making HTTP calls.\n\n\nThat's the basics! We recommend reading the \nresources\n and \nclients\n documentation to understand the full breadth of possibilties with Beckett, or read the \nadvanced\n tips guide for some more exciting features.",
            "title": "Getting Started"
        },
        {
            "location": "/intro/#getting-started",
            "text": "Beckett can be installed using  pip :  pip install beckett  Once installed, use the  Resources  and  Clients  documentation, or read through the concepts tutorial below to familiarise yourself with how Beckett works.",
            "title": "Getting Started"
        },
        {
            "location": "/intro/#concepts",
            "text": "Beckett has two key base models that you'll need to configure in order to get started:  Resources  and  Clients .  We'll using the following snippet of code to explain the basics concepts of Beckett:  # my_client.py\nfrom beckett import clients, resources\n\n\nclass PokemonResource(resources.BaseResource):\n    class Meta(resources.BaseResource.Meta):\n        name = 'Pokemon'\n        identifier = 'id'\n        attributes = (\n            'id',\n            'name',\n        )\n        methods = (\n            'get',\n        )\n\n\nclass PokemonClient(clients.BaseClient):\n    class Meta(clients.BaseClient.Meta):\n        base_url = 'https://pokeapi.co/api/v1/'\n        resources = (\n            PokemonResource,\n        )",
            "title": "Concepts"
        },
        {
            "location": "/intro/#resources",
            "text": "A  Resource  object represents a single resource in your API service:  Resources have a series of attributes in their  Meta  class. These define the attributes and behaviour of a resource.  In this instance, we are naming our resource with the  name  attribute. We're defining a unique  identifier \nattribute to use when querying this resource, and setting a white list of  attributes  that we want to display on this resource.  A full list of available attributes can be found on the  Resources  page.",
            "title": "Resources"
        },
        {
            "location": "/intro/#clients",
            "text": "A typical Beckett-based API client only needs one  Client  instance. However, many clients can be used for versioning.  Clients can be configured using  Meta  class attributes, and inherits the defaults from the  BaseClient .  In this instance we're setting the  base_url  of the API, as well as a list of  resources  that this API supports.  A list of available attributes can be found on the  Clients  page.",
            "title": "Clients"
        },
        {
            "location": "/intro/#example-usage",
            "text": "We can now start calling the API!  from my_client import PokemonClient\n\nmy_client = PokemonClient()\nresult = my_client.get_pokemon(1)[0]\n\nisinstance(result, PokemonResource)\n>>> True\nresult.name\n'Bulbasaur'  Our client generates a collection of methods for every registered resource and understands how to properly call each method.  A lot of stuff is automatically generated here for us, so let's break it down and go through it line by line:  my_client.get_pokemon(uid=1)  The  PokemonClient  will look at  PokemonResource   methods  attribute to determine what HTTP methods are available on it. The default is:  methods = (\n        'get'\n    )  The  PokemonResource  will also set the resource name as the lower-case of the  name  attribute. However, if this resource is called something different in the API we can set it ourselves in  PokemonResource :  resource = 'pokemons'  The  1  will be used by the  identifier  attribute on  PokemonResource  to help construct the URL when making HTTP calls.  That's the basics! We recommend reading the  resources  and  clients  documentation to understand the full breadth of possibilties with Beckett, or read the  advanced  tips guide for some more exciting features.",
            "title": "Example Usage"
        },
        {
            "location": "/resources/",
            "text": "Resources are models relating to individual resources in an HTTP API.\n\n\nclass BaseResource\n\n\nA simple representation of a resource.\n\n\nExample:\n\n\n# myresources.py\nfrom beckett.resources import BaseResource\n\nclass Product(BaseResource):\n\n    class Meta(BaseResource.Meta):\n        name = 'Product'\n        identifier = 'slug'\n        attributes = (\n            'slug',\n            'name',\n            'price',\n            'discount'\n        )\n        methods = (\n            'get',\n        )\n\n\n\n\n\nUsage:\n\n\n# Note: Data will usually come straight from the client method\n>>> data = {'name': 'Tasty product', 'slug': 'sluggy'}\n>>> product = Product(**data)\n<Product | sluggy>\n>>> product.name\n'Tasty product'\n\n\n\n\n- Meta Attributes\n\n\n\n\n\n\n\n\nAttribute\n\n\nRequired\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nYes\n\n\nString\n\n\nThe name of this resource instance. Usually a singular noun.\n\n\n\n\n\n\nresource_name\n\n\nNo\n\n\nString\n\n\nThe name of this resource used in the url. Usually a plural noun. If not set, we'll attempt to make a pluralised version of the \nname\n attribute.\n\n\n\n\n\n\nidentifier\n\n\nYes\n\n\nInt/String\n\n\nThe key attribute that can be used to identify this attribute. Used when referring to related resources.\n\n\n\n\n\n\nattributes\n\n\nYes\n\n\nTuple of Strings\n\n\nA tuple list of strings, referring to the key attributes that you want to populate the resource instances with. You can use this for whitelisting and versioning changes in your API.\n\n\n\n\n\n\nvalid_status_codes\n\n\nNo\n\n\nTuple of Ints\n\n\nA tuple list of integers, referring to the HTTP status codes that are considered \"acceptable\" when communicating with this resource. If a status code is received that does not match this set, an error will be raised.\n\n\n\n\n\n\nmethods\n\n\nNo\n\n\nTuple of Strings\n\n\nA tuple list of strings, referring to the HTTP methods that can be used with this resource. For each method, a python method will be generated on the client that registers this resource.\n\n\n\n\n\n\npagination_key\n\n\nNo\n\n\nString\n\n\nThe key used to look up paginated responses. The value of this key in an API response will be rendered into instances of this resource. See \nPagination\n for more help.\n\n\n\n\n\n\n\n\n- URL generation\n\n\nBeckett attempts to auto generate URLs based on good RESTful style URI schemes. If you do nothing to manipulate the URLs, Beckett will call the following URLs for the related HTTP Methods:\n\n\n\n\n\n\n\n\nMethod\n\n\nURI Structure\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nGET\n\n\nClient.Meta.base_url/Resource.Meta.plural_name/uid\n\n\nhttp://myapi.com/api/products/1/\n\n\n\n\n\n\nPUT\n\n\nClient.Meta.base_url/Resource.Meta.plural_name/uid\n\n\nhttp://myapi.com/api/products/1/\n\n\n\n\n\n\nPOST\n\n\nClient.Meta.base_url/Resource.Meta.plural_name\n\n\nhttp://myapi.com/api/products\n\n\n\n\n\n\nPATCH\n\n\nClient.Meta.base_url/Resource.Meta.plural_name/uid\n\n\nhttp://myapi.com/api/products/1/\n\n\n\n\n\n\nDELETE\n\n\nClient.Meta.base_url/Resource.Meta.plural_name/uid\n\n\nhttp://myapi.com/api/products/1/\n\n\n\n\n\n\n\n\nURL structures can be completely modified by subclassing the \nget_single_resource_url\n method on Resources. See \ncustomising resource urls\n for more information.\n\n\nclass HypermediaResource\n\n\nA simple representation of a resource that supports hypermedia links to related resources.\n\n\nExample:\n\n\n# myresources.py\nfrom beckett.resources import HypermediaResource\n\nclass Designer(HypermediaResource):\n    class Meta(HypermediaResource.Meta):\n        name = 'Designer'\n        identifier = 'slug'\n        attributes = (\n            'slug',\n            'name',\n        )\n        methods = (\n            'get',\n        )\n        # Additional required attributes\n        base_url = 'http://myapi.com/api'\n        related_resources = ()\n\n\nclass Product(HypermediaResource):\n\n    class Meta(HypermediaResource.Meta):\n        name = 'Product'\n        identifier = 'slug'\n        attributes = (\n            'slug',\n            'name',\n            'price',\n            'discount'\n        )\n        methods = (\n            'get',\n        )\n        # Additional required attributes\n        base_url = 'http://myapi.com/api'\n        related_resources = (\n            Designer,\n        )\n\n\n\n\n\nUsage:\n\n\n# Note: Data will usually come straight from the client method\n>>> data = {'name': 'Tasty product', 'slug': 'sluggy', 'designer': 'http://myapi.com/api/designers/some-designer'}\n>>> product = Product(**data)\n>>> product.get_designer(uid='some-designer')\n<Designer | Some Designer>\n\n\n\n\n- Meta Attributes\n\n\nHypermediaResource has two additional, required, attributes that are essential for making hypermedia work\n\n\n\n\n\n\n\n\nAttribute\n\n\nRequired\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbase_url\n\n\nYes\n\n\nString\n\n\nThe base url of this resource\n\n\n\n\n\n\nrelated_resources\n\n\nYes\n\n\nTuple of classes\n\n\nA tuple of classes that are related to this resource, and should be expected in the JSON response from the API.",
            "title": "Resources"
        },
        {
            "location": "/resources/#class-baseresource",
            "text": "A simple representation of a resource.  Example:  # myresources.py\nfrom beckett.resources import BaseResource\n\nclass Product(BaseResource):\n\n    class Meta(BaseResource.Meta):\n        name = 'Product'\n        identifier = 'slug'\n        attributes = (\n            'slug',\n            'name',\n            'price',\n            'discount'\n        )\n        methods = (\n            'get',\n        )  Usage:  # Note: Data will usually come straight from the client method\n>>> data = {'name': 'Tasty product', 'slug': 'sluggy'}\n>>> product = Product(**data)\n<Product | sluggy>\n>>> product.name\n'Tasty product'",
            "title": "class BaseResource"
        },
        {
            "location": "/resources/#-meta-attributes",
            "text": "Attribute  Required  Type  Description      name  Yes  String  The name of this resource instance. Usually a singular noun.    resource_name  No  String  The name of this resource used in the url. Usually a plural noun. If not set, we'll attempt to make a pluralised version of the  name  attribute.    identifier  Yes  Int/String  The key attribute that can be used to identify this attribute. Used when referring to related resources.    attributes  Yes  Tuple of Strings  A tuple list of strings, referring to the key attributes that you want to populate the resource instances with. You can use this for whitelisting and versioning changes in your API.    valid_status_codes  No  Tuple of Ints  A tuple list of integers, referring to the HTTP status codes that are considered \"acceptable\" when communicating with this resource. If a status code is received that does not match this set, an error will be raised.    methods  No  Tuple of Strings  A tuple list of strings, referring to the HTTP methods that can be used with this resource. For each method, a python method will be generated on the client that registers this resource.    pagination_key  No  String  The key used to look up paginated responses. The value of this key in an API response will be rendered into instances of this resource. See  Pagination  for more help.",
            "title": "- Meta Attributes"
        },
        {
            "location": "/resources/#-url-generation",
            "text": "Beckett attempts to auto generate URLs based on good RESTful style URI schemes. If you do nothing to manipulate the URLs, Beckett will call the following URLs for the related HTTP Methods:     Method  URI Structure  Example      GET  Client.Meta.base_url/Resource.Meta.plural_name/uid  http://myapi.com/api/products/1/    PUT  Client.Meta.base_url/Resource.Meta.plural_name/uid  http://myapi.com/api/products/1/    POST  Client.Meta.base_url/Resource.Meta.plural_name  http://myapi.com/api/products    PATCH  Client.Meta.base_url/Resource.Meta.plural_name/uid  http://myapi.com/api/products/1/    DELETE  Client.Meta.base_url/Resource.Meta.plural_name/uid  http://myapi.com/api/products/1/     URL structures can be completely modified by subclassing the  get_single_resource_url  method on Resources. See  customising resource urls  for more information.",
            "title": "- URL generation"
        },
        {
            "location": "/resources/#class-hypermediaresource",
            "text": "A simple representation of a resource that supports hypermedia links to related resources.  Example:  # myresources.py\nfrom beckett.resources import HypermediaResource\n\nclass Designer(HypermediaResource):\n    class Meta(HypermediaResource.Meta):\n        name = 'Designer'\n        identifier = 'slug'\n        attributes = (\n            'slug',\n            'name',\n        )\n        methods = (\n            'get',\n        )\n        # Additional required attributes\n        base_url = 'http://myapi.com/api'\n        related_resources = ()\n\n\nclass Product(HypermediaResource):\n\n    class Meta(HypermediaResource.Meta):\n        name = 'Product'\n        identifier = 'slug'\n        attributes = (\n            'slug',\n            'name',\n            'price',\n            'discount'\n        )\n        methods = (\n            'get',\n        )\n        # Additional required attributes\n        base_url = 'http://myapi.com/api'\n        related_resources = (\n            Designer,\n        )  Usage:  # Note: Data will usually come straight from the client method\n>>> data = {'name': 'Tasty product', 'slug': 'sluggy', 'designer': 'http://myapi.com/api/designers/some-designer'}\n>>> product = Product(**data)\n>>> product.get_designer(uid='some-designer')\n<Designer | Some Designer>",
            "title": "class HypermediaResource"
        },
        {
            "location": "/resources/#-meta-attributes_1",
            "text": "HypermediaResource has two additional, required, attributes that are essential for making hypermedia work     Attribute  Required  Type  Description      base_url  Yes  String  The base url of this resource    related_resources  Yes  Tuple of classes  A tuple of classes that are related to this resource, and should be expected in the JSON response from the API.",
            "title": "- Meta Attributes"
        },
        {
            "location": "/clients/",
            "text": "Clients are models that wrap the interaction with an API service.\n\n\nclass BaseClients\n\n\nA simple HTTP API client.\n\n\nExample:\n\n\n# clients.py\nfrom beckett.clients import BaseClient\nfrom .resources import ProductResource\n\nclass MyClient(BaseClient):\n\n    class Meta(BaseClient.Meta):\n        base_url = 'http://myapi.com/api'\n        resources = (\n            ProductResource,\n        )\n\n\n\n\n\nUsage:\n\n\n# Note: Data will usually come straight from the client method\n>>> client = MyClient()\n# get_, post_, put_, delete_, patch_ methods are auto generated for resources\n>>> product = client.get_product(uid='product_slug')\n>>> product.name\n'Tasty product'\n\n\n\n\nGenerated Methods\n\n\nA number of methods are generated on the client when resources are registered.\n\n\nBased on the \nmethods\n in a \nResource\n, the following methods are created:\n\n\n\n\n\n\n\n\nMethod\n\n\nHTTP method\n\n\nArguments*\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nget\n\n\nGET\n\n\nuid\n\n\nget_product\n\n\n\n\n\n\npost\n\n\nPOST\n\n\ndata\n\n\npost_product\n\n\n\n\n\n\nput\n\n\nPUT\n\n\nuid, data\n\n\nput_product\n\n\n\n\n\n\npatch\n\n\nPATCH\n\n\nuid, data\n\n\npatch_product\n\n\n\n\n\n\ndelete\n\n\nDELETE\n\n\nuid\n\n\ndelete_product\n\n\n\n\n\n\n\n\n* Custom keyword arguments can be passed and will appear in the following methods:\n\n\nBaseResource.get_single_resource_url\n\n\n\n\nThis allows some flexibility when customising these methods.\n\n\nMethod arguments\n\n\n\n\n\n\n\n\nArgument\n\n\nType\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nuid\n\n\nstring or int\n\n\n1\n or \n'some_slug'\n\n\n\n\n\n\ndata\n\n\ndictionary\n\n\n{'name': 'product', 'slug': 'some_slug'}\n\n\n\n\n\n\n\n\n- Meta Attributes\n\n\n\n\n\n\n\n\nAttribute\n\n\nRequired\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbase_url\n\n\nYes\n\n\nString\n\n\nThe Base URL for the HTTP API Service.\n\n\n\n\n\n\nresources\n\n\nYes\n\n\nTuple of Resource objects\n\n\nA tuple of \nResource\n classes that you want to register with this client",
            "title": "Clients"
        },
        {
            "location": "/clients/#class-baseclients",
            "text": "A simple HTTP API client.  Example:  # clients.py\nfrom beckett.clients import BaseClient\nfrom .resources import ProductResource\n\nclass MyClient(BaseClient):\n\n    class Meta(BaseClient.Meta):\n        base_url = 'http://myapi.com/api'\n        resources = (\n            ProductResource,\n        )  Usage:  # Note: Data will usually come straight from the client method\n>>> client = MyClient()\n# get_, post_, put_, delete_, patch_ methods are auto generated for resources\n>>> product = client.get_product(uid='product_slug')\n>>> product.name\n'Tasty product'",
            "title": "class BaseClients"
        },
        {
            "location": "/clients/#generated-methods",
            "text": "A number of methods are generated on the client when resources are registered.  Based on the  methods  in a  Resource , the following methods are created:     Method  HTTP method  Arguments*  Example      get  GET  uid  get_product    post  POST  data  post_product    put  PUT  uid, data  put_product    patch  PATCH  uid, data  patch_product    delete  DELETE  uid  delete_product     * Custom keyword arguments can be passed and will appear in the following methods:  BaseResource.get_single_resource_url  This allows some flexibility when customising these methods.",
            "title": "Generated Methods"
        },
        {
            "location": "/clients/#method-arguments",
            "text": "Argument  Type  Example      uid  string or int  1  or  'some_slug'    data  dictionary  {'name': 'product', 'slug': 'some_slug'}",
            "title": "Method arguments"
        },
        {
            "location": "/clients/#-meta-attributes",
            "text": "Attribute  Required  Type  Description      base_url  Yes  String  The Base URL for the HTTP API Service.    resources  Yes  Tuple of Resource objects  A tuple of  Resource  classes that you want to register with this client",
            "title": "- Meta Attributes"
        },
        {
            "location": "/advanced/",
            "text": "Customising Resource URLs\n\n\nIf you have domain-specific URLs you can modify them individually per Resource.\n\n\nIf we have a resource that requires a URL structure like so:\n\n\nhttps://myapi.com/api/v1/product?id=123&country=GB\n\n\n\n\nWhich would require:\n\n\n\n\nThe URL to accept an \nid\n query parameter\n\n\nAn additional \ncountry\n parameter\n\n\n\n\nThen we can customise our \nProductResource\n like so:\n\n\nclass Product(BaseResource):\n\n    class Meta(BaseResource.Meta):\n        name = 'Product'\n        identifier = 'slug'\n        attributes = (\n            'slug',\n        )\n        methods = (\n            'get',\n        )\n\n    @classmethod\n    def get_single_resource_url(cls, url, uid, **kwargs):\n        \"\"\"\n        Our customised URL.\n        \"\"\"\n        return '{}/products/?id={}&country={}'.format(\n            url,\n            uid,\n            kwargs.get('country')\n        )\n\n\n\n\nWhen we go to use the resource in our client we simply call the \nget_method\n with additional parameters:\n\n\nclient.get_product(uid=1, country='GB')\n>>> <Product | 1>\n\n\n\n\nResponse formats\n\n\nTODO\n\n\nPagination\n\n\nPagination is supported by Beckett. Because there are many forms of pagination, we recommend customising the \nget_single_resource_url\n method on your resource, similarly to the \nexample above\n. Because all keyword arguments are passed to this method, you can call the page like so:\n\n\nresources = client.get_resource(page=2)\n\n\n\n\nand format the URL in the code like so:\n\n\n@classmethod\ndef get_single_resource_url(cls, url, uid, **kwargs):\n    if kwargs.get('page'):\n        return '{}?page={}'.format(\n            url,\n            kwargs.get('page')\n        )\n\n\n\n\nWhen rendering responses into your resource instances, Beckett will perform the following steps:\n\n\n\n\nIs the response a list? If yes - render each item in the list as a Resource.\n\n\nIs the \npagination_key\n value in this resource declared? If yes, look it up in the response object and render that list into resources.\n\n\nAttempt to render the whole response as a single resource instance.\n\n\n\n\npagination_key\n\n\nIn your Resource, declare a pagination_key attribute:\n\n\n\n```python\nclass Product(BaseResource):\n\n    class Meta(BaseResource.Meta):\n        ...\n        pagination_key = 'objects'\n\n\n\n\nTo correspond with a paginated API response like so:\n\n\n{\n    \"next\": \"http://myapi.com/api/resources?page=2\",\n    \"objects\": [\n        {\n            \"name\": \"Resource one\"\n        },\n        {\n            \"name\": \"Resource two\"\n        }\n    ]\n}",
            "title": "Advanced Features"
        },
        {
            "location": "/advanced/#customising-resource-urls",
            "text": "If you have domain-specific URLs you can modify them individually per Resource.  If we have a resource that requires a URL structure like so:  https://myapi.com/api/v1/product?id=123&country=GB  Which would require:   The URL to accept an  id  query parameter  An additional  country  parameter   Then we can customise our  ProductResource  like so:  class Product(BaseResource):\n\n    class Meta(BaseResource.Meta):\n        name = 'Product'\n        identifier = 'slug'\n        attributes = (\n            'slug',\n        )\n        methods = (\n            'get',\n        )\n\n    @classmethod\n    def get_single_resource_url(cls, url, uid, **kwargs):\n        \"\"\"\n        Our customised URL.\n        \"\"\"\n        return '{}/products/?id={}&country={}'.format(\n            url,\n            uid,\n            kwargs.get('country')\n        )  When we go to use the resource in our client we simply call the  get_method  with additional parameters:  client.get_product(uid=1, country='GB')\n>>> <Product | 1>",
            "title": "Customising Resource URLs"
        },
        {
            "location": "/advanced/#response-formats",
            "text": "TODO",
            "title": "Response formats"
        },
        {
            "location": "/advanced/#pagination",
            "text": "Pagination is supported by Beckett. Because there are many forms of pagination, we recommend customising the  get_single_resource_url  method on your resource, similarly to the  example above . Because all keyword arguments are passed to this method, you can call the page like so:  resources = client.get_resource(page=2)  and format the URL in the code like so:  @classmethod\ndef get_single_resource_url(cls, url, uid, **kwargs):\n    if kwargs.get('page'):\n        return '{}?page={}'.format(\n            url,\n            kwargs.get('page')\n        )  When rendering responses into your resource instances, Beckett will perform the following steps:   Is the response a list? If yes - render each item in the list as a Resource.  Is the  pagination_key  value in this resource declared? If yes, look it up in the response object and render that list into resources.  Attempt to render the whole response as a single resource instance.",
            "title": "Pagination"
        },
        {
            "location": "/advanced/#pagination_key",
            "text": "In your Resource, declare a pagination_key attribute:  \n```python\nclass Product(BaseResource):\n\n    class Meta(BaseResource.Meta):\n        ...\n        pagination_key = 'objects'  To correspond with a paginated API response like so:  {\n    \"next\": \"http://myapi.com/api/resources?page=2\",\n    \"objects\": [\n        {\n            \"name\": \"Resource one\"\n        },\n        {\n            \"name\": \"Resource two\"\n        }\n    ]\n}",
            "title": "pagination_key"
        }
    ]
}